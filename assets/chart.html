<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <script src="https://unpkg.com/lightweight-charts@4.1.3/dist/lightweight-charts.standalone.production.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: transparent;
    }
    #chart {
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body>
  <div id="chart"></div>
  <script>
    let chart;
    let candlestickSeries;
    let lineSeries;
    let currentData = [];
    let isDark = false;
    let isPositive = true;
    let chartHeight = 300;

    // Initialize chart
    function initChart() {
      chart = LightweightCharts.createChart(document.getElementById('chart'), {
        width: window.innerWidth,
        height: chartHeight,
        layout: {
          backgroundColor: isDark ? '#000000' : '#ffffff',
          textColor: isDark ? '#ffffff' : '#000000',
        },
        grid: {
          vertLines: {
            color: isDark ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)',
          },
          horzLines: {
            color: isDark ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)',
          },
        },
        timeScale: {
          timeVisible: true,
          secondsVisible: false,
          borderColor: isDark ? 'rgba(255, 255, 255, 0.2)' : 'rgba(0, 0, 0, 0.2)',
        },
        rightPriceScale: {
          borderColor: isDark ? 'rgba(255, 255, 255, 0.2)' : 'rgba(0, 0, 0, 0.2)',
        },
        crosshair: {
          mode: LightweightCharts.CrosshairMode.Normal,
        },
      });

      // Add candlestick series for OHLC data
      candlestickSeries = chart.addCandlestickSeries({
        upColor: isPositive ? '#4CAF50' : '#F44336',
        downColor: isPositive ? '#F44336' : '#4CAF50',
        borderVisible: false,
        wickUpColor: isPositive ? '#4CAF50' : '#F44336',
        wickDownColor: isPositive ? '#F44336' : '#4CAF50',
      });

      // Add line series for fallback
      lineSeries = chart.addLineSeries({
        color: isPositive ? '#4CAF50' : '#F44336',
        lineWidth: 2,
        priceLineVisible: false,
        lastValueVisible: true,
      });
    }

    // Update chart data
    function updateChartData(data, dark, positive, height) {
      if (!chart) {
        isDark = dark;
        isPositive = positive;
        chartHeight = height;
        initChart();
      } else {
        // Update theme if changed
        if (isDark !== dark || isPositive !== positive) {
          isDark = dark;
          isPositive = positive;
          chart.applyOptions({
            layout: {
              backgroundColor: isDark ? '#000000' : '#ffffff',
              textColor: isDark ? '#ffffff' : '#000000',
            },
            grid: {
              vertLines: {
                color: isDark ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)',
              },
              horzLines: {
                color: isDark ? 'rgba(255, 255, 255, 0.1)' : 'rgba(0, 0, 0, 0.1)',
              },
            },
          });
          candlestickSeries.applyOptions({
            upColor: isPositive ? '#4CAF50' : '#F44336',
            downColor: isPositive ? '#F44336' : '#4CAF50',
            wickUpColor: isPositive ? '#4CAF50' : '#F44336',
            wickDownColor: isPositive ? '#F44336' : '#4CAF50',
          });
          lineSeries.applyOptions({
            color: isPositive ? '#4CAF50' : '#F44336',
          });
        }
      }

      if (data && data.length > 0) {
        currentData = data;
        const hasOHLC = data.some(d => d.open && d.high && d.low && d.close);
        
        if (hasOHLC) {
          const ohlcData = data.map(d => ({
            time: d.time,
            open: d.open,
            high: d.high,
            low: d.low,
            close: d.close,
          }));
          candlestickSeries.setData(ohlcData);
          lineSeries.setData([]); // Clear line series
        } else {
          const lineData = data.map(d => ({ time: d.time, value: d.value }));
          lineSeries.setData(lineData);
          candlestickSeries.setData([]); // Clear candlestick series
        }
      }
    }

    // Handle window resize
    window.addEventListener('resize', () => {
      if (chart) {
        chart.applyOptions({ width: window.innerWidth });
      }
    });

    // Expose functions for React Native
    window.updateChartData = function(dataJson, dark, positive, height) {
      try {
        const data = JSON.parse(dataJson);
        updateChartData(data, dark, positive, height);
      } catch (e) {
        console.error('Error updating chart:', e);
      }
    };

    // Initialize on load
    window.addEventListener('load', () => {
      // Chart will be initialized when first data arrives
    });
  </script>
</body>
</html>

